<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Clash Royale Prototype ‚Äì Pockets & Cycling</title>
  <style>
    body {
      margin: 0;
      background: #222;
      color: #fff;
      font-family: Arial, sans-serif;
      text-align: center;
      user-select: none;
    }
    #gameContainer {
      margin: 10px auto;
      width: 720px;
    }
    #ui {
      margin-bottom: 8px;
    }
    #elixirBarOuter {
      width: 320px;
      height: 20px;
      border: 2px solid #fff;
      margin: 0 auto 4px;
      position: relative;
      background: #333;
    }
    #elixirBarInner {
      height: 100%;
      background: linear-gradient(90deg, #7b2cff, #ff4bff);
      width: 0%;
      transition: width 0.1s linear;
    }
    #elixirText {
      font-size: 14px;
      margin-bottom: 6px;
    }

    #handRow {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 10px;
      margin-bottom: 4px;
    }

    #cards {
      display: flex;
      justify-content: center;
      gap: 6px;
      flex-wrap: nowrap;
    }
    .card {
      width: 90px;
      height: 110px;
      border-radius: 8px;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-size: 13px;
      border: 2px solid #aaa;
      transition: transform 0.15s, box-shadow 0.15s, border-color 0.15s;
    }
    .card:hover {
      transform: scale(1.08);
    }
    .card.selected {
      border-color: #ffd700;
      box-shadow: 0 0 10px #ffd700;
    }
    .cardIcon {
      font-size: 26px;
      margin-bottom: 4px;
    }
    .cardCost {
      font-weight: bold;
      margin-top: 4px;
      color: #ffd1ff;
      font-size: 15px;
    }

    #nextCardBox {
      width: 80px;
      height: 100px;
      border-radius: 8px;
      border: 2px dashed #aaa;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      color: #ddd;
    }
    #nextCardBox .cardIcon {
      font-size: 22px;
      margin-bottom: 2px;
    }

    canvas {
      background: #356c4a;
      border: 2px solid #fff;
      display: block;
      margin: 8px auto;
    }

    #doubleElixirBanner {
      font-size: 22px;
      font-weight: bold;
      color: #ff66ff;
      margin-top: 4px;
      display: none;
    }

    #info {
      font-size: 13px;
      margin-top: 4px;
      color: #ccc;
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <h1>Clash Royale Prototype</h1>

    <div id="ui">
      <div id="elixirText">Elixir: 0 / 10</div>
      <div id="elixirBarOuter">
        <div id="elixirBarInner"></div>
      </div>

      <div id="handRow">
        <div id="cards"></div>
        <div id="nextCardBox">
          <div>Next</div>
          <div id="nextCardIcon" class="cardIcon">?</div>
          <div id="nextCardName"></div>
          <div id="nextCardCost" class="cardCost"></div>
        </div>
      </div>

      <div id="doubleElixirBanner">‚ö° 2√ó ELIXIR! ‚ö°</div>
    </div>

    <canvas id="gameCanvas" width="650" height="600"></canvas>
    <div id="info">
      Click on your side to place the selected card.<br/>
      After you take a tower, you can place in that pocket. Ground troops still use bridges.
    </div>
  </div>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    const ARENA = {
      width: canvas.width,
      height: canvas.height,
      riverY: canvas.height / 2,
      bridgeWidth: 90,
      bridgeGap: 220,
    };

    const bridges = [
      {
        x: ARENA.width / 2 - ARENA.bridgeGap / 2 - ARENA.bridgeWidth,
        y: ARENA.riverY - 10,
        width: ARENA.bridgeWidth,
        height: 20,
      },
      {
        x: ARENA.width / 2 + ARENA.bridgeGap / 2,
        y: ARENA.riverY - 10,
        width: ARENA.bridgeWidth,
        height: 20,
      },
    ];

    const ELIXIR_MAX = 10;
    let elixir = 5;
    let botElixir = 5;

    let elixirRegenBase = 0.35;
    let elixirRegen = elixirRegenBase;
    let botElixirRegen = elixirRegenBase;

    let doubleElixir = false;
    let gameTime = 0;

    const elixirText = document.getElementById("elixirText");
    const elixirBarInner = document.getElementById("elixirBarInner");
    const doubleElixirBanner = document.getElementById("doubleElixirBanner");

    const cardsContainer = document.getElementById("cards");
    const nextCardIcon = document.getElementById("nextCardIcon");
    const nextCardName = document.getElementById("nextCardName");
    const nextCardCost = document.getElementById("nextCardCost");

    const CARDS = [
      { id: "knight", name: "Knight", icon: "üõ°Ô∏è", color: "#8b5", cost: 3, speed: 40, hp: 800, dmg: 80, range: 20, type: "ground" },
      { id: "archers", name: "Archers", icon: "üèπ", color: "#6bf", cost: 3, speed: 45, hp: 250, dmg: 60, range: 90, type: "air" },
      { id: "giant", name: "Giant", icon: "üí™", color: "#d93", cost: 5, speed: 30, hp: 2000, dmg: 150, range: 20, type: "ground" },
      { id: "minions", name: "Minions", icon: "üëæ", color: "#66f", cost: 3, speed: 55, hp: 190, dmg: 70, range: 20, type: "air" },
      { id: "baby_dragon", name: "Baby Dragon", icon: "üêâ", color: "#4f8", cost: 4, speed: 45, hp: 1200, dmg: 100, range: 80, type: "air" },
      { id: "mini_pekka", name: "Mini P.E.K.K.A", icon: "ü§ñ", color: "#f55", cost: 4, speed: 50, hp: 1100, dmg: 300, range: 20, type: "ground" },
      { id: "fireball", name: "Fireball", icon: "üî•", color: "#f33", cost: 4, spell: true, radius: 60, dmg: 300 },
      { id: "arrows", name: "Arrows", icon: "üéØ", color: "#fff", cost: 3, spell: true, radius: 80, dmg: 150 },
    ];

    const PLAYER_DECK = [...CARDS];
    const BOT_DECK = [...CARDS];

    let playerHandIndices = [0, 1, 2, 3];
    let playerNextIndex = 4;

    let botHandIndices = [0, 1, 2, 3];
    let botNextIndex = 4;

    let selectedHandSlot = 0;

    function getCardFromDeck(deck, index) {
      return deck[index % deck.length];
    }

    function cyclePlayerCard(slotIndex) {
      playerHandIndices[slotIndex] = playerNextIndex;
      playerNextIndex = (playerNextIndex + 1) % PLAYER_DECK.length;
    }

    function cycleBotCard(slotIndex) {
      botHandIndices[slotIndex] = botNextIndex;
      botNextIndex = (botNextIndex + 1) % BOT_DECK.length;
    }

    function updateElixirUI() {
      elixirText.textContent = `Elixir: ${elixir.toFixed(1)} / ${ELIXIR_MAX}`;
      const pct = (elixir / ELIXIR_MAX) * 100;
      elixirBarInner.style.width = `${Math.min(100, pct)}%`;
    }

    function renderHandUI() {
      cardsContainer.innerHTML = "";
      for (let i = 0; i < playerHandIndices.length; i++) {
        const card = getCardFromDeck(PLAYER_DECK, playerHandIndices[i]);
        const div = document.createElement("div");
        div.className = "card" + (i === selectedHandSlot ? " selected" : "");
        div.style.background = card.color;
        div.dataset.slot = i;

        div.innerHTML = `
          <div class="cardIcon">${card.icon}</div>
          <div>${card.name}</div>
          <div class="cardCost">${card.cost}</div>
        `;

        div.onclick = () => {
          selectedHandSlot = i;
          renderHandUI();
        };

        cardsContainer.appendChild(div);
      }

      const nextCard = getCardFromDeck(PLAYER_DECK, playerNextIndex);
      nextCardIcon.textContent = nextCard.icon;
      nextCardName.textContent = nextCard.name;
      nextCardCost.textContent = nextCard.cost;
    }

    renderHandUI();
    updateElixirUI();

    function createTowers() {
      const bottomY = ARENA.height - 80;
      const topY = 40;
      const sideOffset = 120;
      const kingOffsetY = 40;

      return {
        player: {
          king: {
            x: ARENA.width / 2,
            y: bottomY + kingOffsetY,
            w: 40,
            h: 40,
            hp: 4000,
            maxHp: 4000,
            active: false,
            side: "player",
            type: "king",
          },
          leftPrincess: {
            x: sideOffset,
            y: bottomY,
            w: 40,
            h: 40,
            hp: 2500,
            maxHp: 2500,
            active: true,
            side: "player",
            type: "princess",
          },
          rightPrincess: {
            x: ARENA.width - sideOffset,
            y: bottomY,
            w: 40,
            h: 40,
            hp: 2500,
            maxHp: 2500,
            active: true,
            side: "player",
            type: "princess",
          },
        },
        bot: {
          king: {
            x: ARENA.width / 2,
            y: topY - kingOffsetY,
            w: 40,
            h: 40,
            hp: 4000,
            maxHp: 4000,
            active: false,
            side: "bot",
            type: "king",
          },
          leftPrincess: {
            x: sideOffset,
            y: topY,
            w: 40,
            h: 40,
            hp: 2500,
            maxHp: 2500,
            active: true,
            side: "bot",
            type: "princess",
          },
          rightPrincess: {
            x: ARENA.width - sideOffset,
            y: topY,
            w: 40,
            h: 40,
            hp: 2500,
            maxHp: 2500,
            active: true,
            side: "bot",
            type: "princess",
          },
        },
      };
    }

    let towers = createTowers();
    const units = [];
    const spells = [];

    function distance(a, b) {
      const dx = a.x - b.x;
      const dy = a.y - b.y;
      return Math.sqrt(dx * dx + dy * dy);
    }

    function getAllTowersArray() {
      return [
        towers.player.king,
        towers.player.leftPrincess,
        towers.player.rightPrincess,
        towers.bot.king,
        towers.bot.leftPrincess,
        towers.bot.rightPrincess,
      ];
    }

    function getEnemyTowers(side) {
      return side === "player"
        ? [towers.bot.leftPrincess, towers.bot.rightPrincess, towers.bot.king]
        : [towers.player.leftPrincess, towers.player.rightPrincess, towers.player.king];
    }

    // Pocket rectangles (enemy side pockets for player, and vice versa)
    function getPlayerPockets() {
      const pockets = [];
      const enemy = towers.bot;
      const king = enemy.king;

      if (enemy.leftPrincess.hp <= 0) {
        pockets.push({
          x1: Math.min(enemy.leftPrincess.x, king.x) - 40,
          x2: Math.max(enemy.leftPrincess.x, king.x) + 40,
          y1: enemy.leftPrincess.y - 40,
          y2: king.y + 40,
        });
      }
      if (enemy.rightPrincess.hp <= 0) {
        pockets.push({
          x1: Math.min(enemy.rightPrincess.x, king.x) - 40,
          x2: Math.max(enemy.rightPrincess.x, king.x) + 40,
          y1: enemy.rightPrincess.y - 40,
          y2: king.y + 40,
        });
      }
      return pockets;
    }

    function getBotPockets() {
      const pockets = [];
      const enemy = towers.player;
      const king = enemy.king;

      if (enemy.leftPrincess.hp <= 0) {
        pockets.push({
          x1: Math.min(enemy.leftPrincess.x, king.x) - 40,
          x2: Math.max(enemy.leftPrincess.x, king.x) + 40,
          y1: king.y - 40,
          y2: enemy.leftPrincess.y + 40,
        });
      }
      if (enemy.rightPrincess.hp <= 0) {
        pockets.push({
          x1: Math.min(enemy.rightPrincess.x, king.x) - 40,
          x2: Math.max(enemy.rightPrincess.x, king.x) + 40,
          y1: king.y - 40,
          y2: enemy.rightPrincess.y + 40,
        });
      }
      return pockets;
    }

    function pointInRect(x, y, r) {
      return x >= r.x1 && x <= r.x2 && y >= r.y1 && y <= r.y2;
    }

    function canPlaceCardAt(card, x, y, side) {
      if (card.spell) return true; // spells anywhere

      if (side === "player") {
        if (y > ARENA.riverY + 10) return true; // own side
        const pockets = getPlayerPockets();
        for (const p of pockets) {
          if (pointInRect(x, y, p)) return true;
        }
        return false;
      } else {
        if (y < ARENA.riverY - 10) return true; // bot own side
        const pockets = getBotPockets();
        for (const p of pockets) {
          if (pointInRect(x, y, p)) return true;
        }
        return false;
      }
    }

    function spawnUnit(card, x, y, side) {
      units.push({
        x,
        y,
        side,
        card,
        hp: card.hp,
        target: null,
        attackCooldown: 0,
      });
    }

    function spawnSpell(card, x, y, side) {
      spells.push({
        x,
        y,
        side,
        card,
        time: 0.3,
      });

      const allTowers = getAllTowersArray();
      allTowers.forEach((t) => {
        if (t.hp > 0 && distance({ x, y }, t) <= card.radius) {
          t.hp -= card.dmg;
          if (t.hp < 0) t.hp = 0;

          if (t.type === "king") {
            t.active = true;
          }

          if (t.type === "princess" && t.hp <= 0) {
            const owner = t.side === "player" ? towers.player : towers.bot;
            owner.king.active = true;
          }
        }
      });

      units.forEach((u) => {
        if (u.hp > 0 && distance({ x, y }, u) <= card.radius) {
          u.hp -= card.dmg;
          if (u.hp < 0) u.hp = 0;
        }
      });
    }

    canvas.addEventListener("click", (e) => {
      if (gameOver) return;
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      const cardIndex = playerHandIndices[selectedHandSlot];
      const card = getCardFromDeck(PLAYER_DECK, cardIndex);
      if (!card) return;
      if (elixir < card.cost) return;
      if (!canPlaceCardAt(card, x, y, "player")) return;

      elixir -= card.cost;
      updateElixirUI();

      if (card.spell) {
        spawnSpell(card, x, y, "player");
      } else {
        spawnUnit(card, x, y, "player");
      }

      cyclePlayerCard(selectedHandSlot);
      renderHandUI();
    });

    let botDecisionTimer = 0;

    function botUpdate(dt) {
      botElixir = Math.min(ELIXIR_MAX, botElixir + botElixirRegen * dt);

      botDecisionTimer -= dt;
      if (botDecisionTimer > 0) return;

      botDecisionTimer = 1.5 + Math.random() * 1.5;

      const playableSlots = [];
      for (let i = 0; i < botHandIndices.length; i++) {
        const card = getCardFromDeck(BOT_DECK, botHandIndices[i]);
        if (card.cost <= botElixir) playableSlots.push(i);
      }
      if (playableSlots.length === 0) return;

      const slot = playableSlots[Math.floor(Math.random() * playableSlots.length)];
      const cardIndex = botHandIndices[slot];
      const card = getCardFromDeck(BOT_DECK, cardIndex);

      let x = 80 + Math.random() * (ARENA.width - 160);
      let y = 40 + Math.random() * (ARENA.riverY - 80);

      const pockets = getBotPockets();
      if (pockets.length > 0 && Math.random() < 0.5) {
        const p = pockets[Math.floor(Math.random() * pockets.length)];
        x = p.x1 + Math.random() * (p.x2 - p.x1);
        y = p.y1 + Math.random() * (p.y2 - p.y1);
      }

      if (!canPlaceCardAt(card, x, y, "bot")) return;

      botElixir -= card.cost;

      if (card.spell) {
        spawnSpell(card, x, y, "bot");
      } else {
        spawnUnit(card, x, y, "bot");
      }

      cycleBotCard(slot);
    }

    function getGroundTargetPosition(unit, targetTower) {
      const goingUp = unit.side === "player";
      if ((goingUp && unit.y <= ARENA.riverY) || (!goingUp && unit.y >= ARENA.riverY)) {
        return { x: targetTower.x, y: targetTower.y };
      }

      const bridgeCenters = bridges.map((b) => ({ x: b.x + b.width / 2, y: ARENA.riverY }));
      let best = bridgeCenters[0];
      let bestDist = Math.abs(unit.x - best.x);
      for (let i = 1; i < bridgeCenters.length; i++) {
        const d = Math.abs(unit.x - bridgeCenters[i].x);
        if (d < bestDist) {
          bestDist = d;
          best = bridgeCenters[i];
        }
      }
      return best;
    }

    function updateUnits(dt) {
      const allTowers = getAllTowersArray();

      units.forEach((u) => {
        if (u.hp <= 0) return;

        let nearest = null;
        let nearestDist = Infinity;

        units.forEach((other) => {
          if (other === u || other.hp <= 0) return;
          if (other.side === u.side) return;
          const d = distance(u, other);
          if (d < nearestDist) {
            nearestDist = d;
            nearest = other;
          }
        });

        allTowers.forEach((t) => {
          if (t.hp <= 0) return;
          if (t.side === u.side) return;
          const d = distance(u, t);
          if (d < nearestDist) {
            nearestDist = d;
            nearest = t;
          }
        });

        u.attackCooldown -= dt;

        if (nearest && nearestDist <= u.card.range) {
          if (u.attackCooldown <= 0) {
            u.attackCooldown = 1;
            nearest.hp -= u.card.dmg;
            if (nearest.hp < 0) nearest.hp = 0;

            if (nearest.type === "princess" && nearest.hp <= 0) {
              const owner = nearest.side === "player" ? towers.player : towers.bot;
              owner.king.active = true;
            }
          }
        } else {
          const enemyTowers = getEnemyTowers(u.side).filter((t) => t.hp > 0);
          if (enemyTowers.length === 0) return;
          const primaryTarget = enemyTowers[0];

          let targetPos;
          if (u.card.type === "ground") {
            targetPos = getGroundTargetPosition(u, primaryTarget);
          } else {
            targetPos = { x: primaryTarget.x, y: primaryTarget.y };
          }

          const dx = targetPos.x - u.x;
          const dy = targetPos.y - u.y;
          const len = Math.sqrt(dx * dx + dy * dy) || 1;
          const vx = (dx / len) * u.card.speed;
          const vy = (dy / len) * u.card.speed;

          u.x += vx * dt;
          u.y += vy * dt;
        }
      });

      for (let i = units.length - 1; i >= 0; i--) {
        if (units[i].hp <= 0) units.splice(i, 1);
      }
    }

    function updateTowers(dt) {
      const allTowers = getAllTowersArray();

      allTowers.forEach((t) => {
        if (t.hp <= 0) return;
        if (t.type === "king" && !t.active) return;

        if (!t.attackCooldown) t.attackCooldown = 0;
        t.attackCooldown -= dt;

        const baseRange = t.type === "king" ? 130 : 160; // princess range extended
        let nearest = null;
        let nearestDist = Infinity;

        units.forEach((u) => {
          if (u.side === t.side || u.hp <= 0) return;

          // prevent princess shooting past river
          if (t.type === "princess") {
            if (t.side === "player" && u.y < ARENA.riverY - 5) return;
            if (t.side === "bot" && u.y > ARENA.riverY + 5) return;
          }

          const d = distance(u, t);
          if (d < nearestDist && d <= baseRange) {
            nearestDist = d;
            nearest = u;
          }
        });

        if (nearest && t.attackCooldown <= 0) {
          t.attackCooldown = 1;
          nearest.hp -= t.type === "king" ? 120 : 90;
          if (nearest.hp < 0) nearest.hp = 0;
        }
      });
    }

    function updateSpells(dt) {
      for (let i = spells.length - 1; i >= 0; i--) {
        spells[i].time -= dt;
        if (spells[i].time <= 0) spells.splice(i, 1);
      }
    }

    function checkGameEnd() {
      if (towers.player.king.hp <= 0) return "bot";
      if (towers.bot.king.hp <= 0) return "player";
      return null;
    }

    function drawArena() {
      ctx.fillStyle = "#356c4a";
      ctx.fillRect(0, 0, ARENA.width, ARENA.height);

      ctx.fillStyle = "#3b7bbf";
      ctx.fillRect(0, ARENA.riverY - 20, ARENA.width, 40);

      ctx.fillStyle = "#b58b4a";
      bridges.forEach((b) => {
        ctx.fillRect(b.x, b.y, b.width, b.height);
      });

      ctx.strokeStyle = "rgba(255,255,255,0.2)";
      ctx.beginPath();
      ctx.moveTo(0, ARENA.riverY);
      ctx.lineTo(ARENA.width, ARENA.riverY);
      ctx.stroke();
    }

    function drawTower(t) {
      if (t.hp <= 0) return;
      ctx.save();
      ctx.translate(t.x, t.y);
      ctx.fillStyle = t.side === "player" ? "#ffcc66" : "#66aaff";
      ctx.fillRect(-t.w / 2, -t.h / 2, t.w, t.h);

      if (t.type === "king") {
        ctx.fillStyle = t.active ? "#ff4444" : "#999";
        ctx.beginPath();
        ctx.arc(0, -t.h / 2 - 6, 8, 0, Math.PI * 2);
        ctx.fill();
      }

      const hpPct = t.hp / t.maxHp;
      ctx.fillStyle = "#000";
      ctx.fillRect(-20, t.h / 2 + 4, 40, 5);
      ctx.fillStyle = "#0f0";
      ctx.fillRect(-20, t.h / 2 + 4, 40 * hpPct, 5);

      ctx.restore();
    }

    function drawUnit(u) {
      if (u.hp <= 0) return;
      ctx.save();
      ctx.translate(u.x, u.y);

      // Unique "art" per troop
      if (u.card.id === "knight") {
        ctx.fillStyle = u.side === "player" ? "#c9a34f" : "#7fa0d9";
        ctx.fillRect(-10, -16, 20, 32);
        ctx.fillStyle = "#444";
        ctx.fillRect(-8, -20, 16, 8);
      } else if (u.card.id === "archers") {
        ctx.fillStyle = u.side === "player" ? "#7fd9ff" : "#ff9fd9";
        ctx.beginPath();
        ctx.ellipse(0, 0, 10, 14, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = "#222";
        ctx.beginPath();
        ctx.moveTo(-10, 0);
        ctx.lineTo(10, 0);
        ctx.stroke();
      } else if (u.card.id === "giant") {
        ctx.fillStyle = u.side === "player" ? "#d98b4f" : "#b5651d";
        ctx.fillRect(-14, -20, 28, 40);
        ctx.fillStyle = "#333";
        ctx.fillRect(-10, -26, 20, 10);
      } else if (u.card.id === "minions") {
        ctx.fillStyle = u.side === "player" ? "#6666ff" : "#4444aa";
        ctx.beginPath();
        ctx.arc(-6, 0, 7, 0, Math.PI * 2);
        ctx.arc(6, 0, 7, 0, Math.PI * 2);
        ctx.fill();
      } else if (u.card.id === "baby_dragon") {
        ctx.fillStyle = u.side === "player" ? "#4ff88a" : "#3bbf6a";
        ctx.beginPath();
        ctx.ellipse(0, 0, 14, 10, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = "#2a5";
        ctx.beginPath();
        ctx.moveTo(-14, 0);
        ctx.lineTo(-24, -6);
        ctx.lineTo(-24, 6);
        ctx.closePath();
        ctx.fill();
      } else if (u.card.id === "mini_pekka") {
        ctx.fillStyle = u.side === "player" ? "#88c" : "#446";
        ctx.fillRect(-10, -16, 20, 32);
        ctx.fillStyle = "#222";
        ctx.fillRect(-8, -22, 16, 10);
      } else {
        // fallback
        ctx.fillStyle = u.side === "player" ? "#ff66aa" : "#66ddff";
        ctx.beginPath();
        ctx.arc(0, 0, 10, 0, Math.PI * 2);
        ctx.fill();
      }

      // HP bar
      const hpPct = u.hp / u.card.hp;
      ctx.fillStyle = "#000";
      ctx.fillRect(-12, 14, 24, 4);
      ctx.fillStyle = "#0f0";
      ctx.fillRect(-12, 14, 24 * hpPct, 4);

      // Name tag (identify enemy cards)
      ctx.font = "10px Arial";
      ctx.textAlign = "center";
      ctx.fillStyle = "#fff";
      ctx.fillText(u.card.name, 0, -20);

      ctx.restore();
    }

    function drawSpell(s) {
      ctx.save();
      ctx.globalAlpha = 0.5;
      ctx.fillStyle = s.card.id === "fireball" ? "#ff6600" : "#ffffff";
      ctx.beginPath();
      ctx.arc(s.x, s.y, s.card.radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    function drawTowers() {
      const allTowers = getAllTowersArray();
      allTowers.forEach(drawTower);
    }

    function drawUnits() {
      units.forEach(drawUnit);
    }

    function drawSpells() {
      spells.forEach(drawSpell);
    }

    function drawGameOver(winner) {
      ctx.fillStyle = "rgba(0,0,0,0.7)";
      ctx.fillRect(0, 0, ARENA.width, ARENA.height);
      ctx.fillStyle = "#fff";
      ctx.font = "36px Arial";
      ctx.textAlign = "center";
      ctx.fillText(
        winner === "player" ? "You Win!" : "You Lose!",
        ARENA.width / 2,
        ARENA.height / 2
      );
      ctx.font = "20px Arial";
      ctx.fillText("Refresh the page to play again.", ARENA.width / 2, ARENA.height / 2 + 40);
    }

    let lastTime = performance.now();
    let gameOver = false;
    let winner = null;

    function loop(now) {
      const dt = (now - lastTime) / 1000;
      lastTime = now;

      if (!gameOver) {
        gameTime += dt;

        if (!doubleElixir && gameTime >= 120) {
          doubleElixir = true;
          elixirRegen = elixirRegenBase * 2;
          botElixirRegen = elixirRegenBase * 2;
          doubleElixirBanner.style.display = "block";
        }

        elixir = Math.min(ELIXIR_MAX, elixir + elixirRegen * dt);
        updateElixirUI();

        botUpdate(dt);
        updateUnits(dt);
        updateTowers(dt);
        updateSpells(dt);

        winner = checkGameEnd();
        if (winner) {
          gameOver = true;
        }
      }

      drawArena();
      drawTowers();
      drawUnits();
      drawSpells();

      if (gameOver) {
        drawGameOver(winner);
      }

      requestAnimationFrame(loop);
    }

    requestAnimationFrame(loop);
  </script>
</body>
</html>
