<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Clash Royale‚Äëlike ‚Äì Bigger Pockets & More Cards</title>
  <style>
    body {
      margin: 0;
      background: #181818;
      color: #fff;
      font-family: Arial, sans-serif;
      text-align: center;
      user-select: none;
    }
    #gameContainer {
      margin: 10px auto;
      width: 780px;
    }
    #ui {
      margin-bottom: 8px;
    }
    #elixirBarOuter {
      width: 360px;
      height: 20px;
      border: 2px solid #fff;
      margin: 0 auto 4px;
      position: relative;
      background: #333;
      box-shadow: 0 0 8px rgba(0,0,0,0.6);
    }
    #elixirBarInner {
      height: 100%;
      background: linear-gradient(90deg, #7b2cff, #ff4bff);
      width: 0%;
      transition: width 0.1s linear;
    }
    #elixirText {
      font-size: 14px;
      margin-bottom: 6px;
    }

    #handRow {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 10px;
      margin-bottom: 4px;
    }

    #cards {
      display: flex;
      justify-content: center;
      gap: 6px;
      flex-wrap: nowrap;
    }
    .card {
      width: 90px;
      height: 110px;
      border-radius: 12px;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-size: 13px;
      border: 2px solid #aaa;
      transition: transform 0.15s, box-shadow 0.15s, border-color 0.15s;
      box-shadow: 0 0 6px rgba(0,0,0,0.5);
      background: radial-gradient(circle at 30% 20%, #fff4, transparent 60%), #555;
      position: relative;
      overflow: hidden;
    }
    .card::before {
      content: "";
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, #ffffff22, #00000033);
      mix-blend-mode: soft-light;
      pointer-events: none;
    }
    .card:hover {
      transform: translateY(-3px) scale(1.05);
      box-shadow: 0 4px 10px rgba(0,0,0,0.7);
    }
    .card.selected {
      border-color: #ffd700;
      box-shadow: 0 0 12px #ffd700;
    }
    .cardIcon {
      font-size: 26px;
      margin-bottom: 4px;
      text-shadow: 0 0 4px #000;
    }
    .cardCost {
      font-weight: bold;
      margin-top: 4px;
      color: #ffd1ff;
      font-size: 15px;
      text-shadow: 0 0 4px #000;
    }

    #nextCardBox {
      width: 80px;
      height: 100px;
      border-radius: 10px;
      border: 2px dashed #aaa;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      color: #ddd;
      box-shadow: 0 0 6px rgba(0,0,0,0.5);
      background: #444;
      position: relative;
      overflow: hidden;
    }
    #nextCardBox::before {
      content: "";
      position: absolute;
      inset: 0;
      background: linear-gradient(145deg, #ffffff22, #00000033);
      mix-blend-mode: soft-light;
      pointer-events: none;
    }
    #nextCardBox .cardIcon {
      font-size: 22px;
      margin-bottom: 2px;
    }

    canvas {
      background: #356c4a;
      border: 2px solid #fff;
      display: block;
      margin: 8px auto;
      box-shadow: 0 0 12px rgba(0,0,0,0.8);
    }

    #doubleElixirBanner {
      font-size: 22px;
      font-weight: bold;
      color: #ff66ff;
      margin-top: 4px;
      display: none;
      text-shadow: 0 0 8px #ff66ff;
    }

    #info {
      font-size: 13px;
      margin-top: 4px;
      color: #ccc;
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <h1>Clash Royale‚Äëlike ‚Äì Bigger Pockets & More Cards</h1>

    <div id="ui">
      <div id="elixirText">Elixir: 0 / 10</div>
      <div id="elixirBarOuter">
        <div id="elixirBarInner"></div>
      </div>

      <div id="handRow">
        <div id="cards"></div>
        <div id="nextCardBox">
          <div>Next</div>
          <div id="nextCardIcon" class="cardIcon">?</div>
          <div id="nextCardName"></div>
          <div id="nextCardCost" class="cardCost"></div>
        </div>
      </div>

      <div id="doubleElixirBanner">‚ö° 2√ó ELIXIR! ‚ö°</div>
    </div>

    <canvas id="gameCanvas" width="650" height="600"></canvas>
    <div id="info">
      Click a card, drag onto the arena, and release to place.<br/>
      Pockets unlock when you take a princess tower; they‚Äôre bigger and further up now.
    </div>
  </div>

  <script>
    // =========================
    // BASIC CONSTANTS & SETUP
    // =========================
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    const ARENA = {
      width: canvas.width,
      height: canvas.height,
      riverY: canvas.height / 2,
      bridgeWidth: 90,
      bridgeGap: 220,
    };

    const bridges = [
      {
        x: ARENA.width / 2 - ARENA.bridgeGap / 2 - ARENA.bridgeWidth,
        y: ARENA.riverY - 10,
        width: ARENA.bridgeWidth,
        height: 20,
      },
      {
        x: ARENA.width / 2 + ARENA.bridgeGap / 2,
        y: ARENA.riverY - 10,
        width: ARENA.bridgeWidth,
        height: 20,
      },
    ];

    const ELIXIR_MAX = 10;
    let elixir = 5;
    let botElixir = 5;

    let elixirRegenBase = 0.35;
    let elixirRegen = elixirRegenBase;
    let botElixirRegen = elixirRegenBase;

    let doubleElixir = false;
    let gameTime = 0;

    const elixirText = document.getElementById("elixirText");
    const elixirBarInner = document.getElementById("elixirBarInner");
    const doubleElixirBanner = document.getElementById("doubleElixirBanner");

    const cardsContainer = document.getElementById("cards");
    const nextCardIcon = document.getElementById("nextCardIcon");
    const nextCardName = document.getElementById("nextCardName");
    const nextCardCost = document.getElementById("nextCardCost");

    // =========================
    // CARD DEFINITIONS
    // =========================
    const CARDS = [
      {
        id: "knight",
        name: "Knight",
        icon: "üõ°Ô∏è",
        color: "#8b5",
        cost: 3,
        speed: 40,
        hp: 900,
        dmg: 120,
        range: 20,
        attackSpeed: 1.1,
        aggroRange: 90,
        type: "ground",
        targetType: "ground",
        radius: 16,
      },
      {
        id: "archers",
        name: "Archers",
        icon: "üèπ",
        color: "#6bf",
        cost: 3,
        speed: 45,
        hp: 280,
        dmg: 70,
        range: 120,
        attackSpeed: 1.0,
        aggroRange: 130,
        type: "ground",
        targetType: "air_ground",
        radius: 14,
      },
      {
        id: "giant",
        name: "Giant",
        icon: "üí™",
        color: "#d93",
        cost: 5,
        speed: 28,
        hp: 2300,
        dmg: 190,
        range: 20,
        attackSpeed: 1.4,
        aggroRange: 70,
        type: "ground",
        targetType: "building",
        radius: 18,
      },
      {
        id: "minions",
        name: "Minions",
        icon: "üëæ",
        color: "#66f",
        cost: 3,
        speed: 60,
        hp: 260,      // buffed
        dmg: 95,      // buffed
        range: 20,
        attackSpeed: 1.0,
        aggroRange: 110,
        type: "air",
        targetType: "air_ground",
        radius: 14,
      },
      {
        id: "baby_dragon",
        name: "Baby Dragon",
        icon: "üêâ",
        color: "#4f8",
        cost: 4,
        speed: 45,
        hp: 1300,
        dmg: 110,
        range: 95,
        attackSpeed: 1.1,
        aggroRange: 130,
        type: "air",
        targetType: "air_ground",
        radius: 18,
      },
      {
        id: "mini_pekka",
        name: "Mini P.E.K.K.A",
        icon: "ü§ñ",
        color: "#f55",
        cost: 4,
        speed: 55,
        hp: 1200,
        dmg: 320,
        range: 20,
        attackSpeed: 1.2,
        aggroRange: 90,
        type: "ground",
        targetType: "ground",
        radius: 16,
      },
      {
        id: "musketeer",
        name: "Musketeer",
        icon: "üî´",
        color: "#9cf",
        cost: 4,
        speed: 45,
        hp: 600,
        dmg: 160,
        range: 140,
        attackSpeed: 1.1,
        aggroRange: 150,
        type: "ground",
        targetType: "air_ground",
        radius: 14,
      },
      {
        id: "valkyrie",
        name: "Valkyrie",
        icon: "üåÄ",
        color: "#f96",
        cost: 4,
        speed: 40,
        hp: 1350,
        dmg: 150,
        range: 35,
        attackSpeed: 1.0,
        aggroRange: 80,
        type: "ground",
        targetType: "ground",
        radius: 18,
        splash: true,
        splashRadius: 40,
      },
      {
        id: "wizard",
        name: "Wizard",
        icon: "üßô‚Äç‚ôÇÔ∏è",
        color: "#a6f",
        cost: 5,
        speed: 40,
        hp: 700,
        dmg: 220,
        range: 130,
        attackSpeed: 1.4,
        aggroRange: 150,
        type: "ground",
        targetType: "air_ground",
        radius: 14,
        splash: true,
        splashRadius: 55,
      },
      {
        id: "fireball",
        name: "Fireball",
        icon: "üî•",
        color: "#f33",
        cost: 4,
        spell: true,
        radius: 60,
        dmg: 350,
      },
      {
        id: "arrows",
        name: "Arrows",
        icon: "üéØ",
        color: "#fff",
        cost: 3,
        spell: true,
        radius: 80,
        dmg: 170,
      },
    ];

    const PLAYER_DECK = [...CARDS];
    const BOT_DECK = [...CARDS];

    let playerHandIndices = [0, 1, 2, 3];
    let playerNextIndex = 4;

    let botHandIndices = [0, 1, 2, 3];
    let botNextIndex = 4;

    let selectedHandSlot = 0;

    function getCardFromDeck(deck, index) {
      return deck[index % deck.length];
    }

    function cyclePlayerCard(slotIndex) {
      playerHandIndices[slotIndex] = playerNextIndex;
      playerNextIndex = (playerNextIndex + 1) % PLAYER_DECK.length;
    }

    function cycleBotCard(slotIndex) {
      botHandIndices[slotIndex] = botNextIndex;
      botNextIndex = (botNextIndex + 1) % BOT_DECK.length;
    }

    function updateElixirUI() {
      elixirText.textContent = `Elixir: ${elixir.toFixed(1)} / ${ELIXIR_MAX}`;
      const pct = (elixir / ELIXIR_MAX) * 100;
      elixirBarInner.style.width = `${Math.min(100, pct)}%`;
    }

    function renderHandUI() {
      cardsContainer.innerHTML = "";
      for (let i = 0; i < playerHandIndices.length; i++) {
        const card = getCardFromDeck(PLAYER_DECK, playerHandIndices[i]);
        const div = document.createElement("div");
        div.className = "card" + (i === selectedHandSlot ? " selected" : "");
        div.style.backgroundColor = card.color;
        div.dataset.slot = i;

        div.innerHTML = `
          <div class="cardIcon">${card.icon}</div>
          <div>${card.name}</div>
          <div class="cardCost">${card.cost}</div>
        `;

        div.onmousedown = (ev) => {
          ev.preventDefault();
          startDraggingCard(i);
        };

        div.onclick = () => {
          selectedHandSlot = i;
          renderHandUI();
        };

        cardsContainer.appendChild(div);
      }

      const nextCard = getCardFromDeck(PLAYER_DECK, playerNextIndex);
      nextCardIcon.textContent = nextCard.icon;
      nextCardName.textContent = nextCard.name;
      nextCardCost.textContent = nextCard.cost;
    }

    renderHandUI();
    updateElixirUI();

    // =========================
    // TOWERS
    // =========================
    function createTowers() {
      const bottomY = ARENA.height - 80;
      const topY = 40;
      const sideOffset = 120;
      const kingOffsetY = 40;

      return {
        player: {
          king: {
            x: ARENA.width / 2,
            y: bottomY + kingOffsetY,
            w: 46,
            h: 46,
            hp: 4000,
            maxHp: 4000,
            active: false,
            side: "player",
            type: "king",
          },
          leftPrincess: {
            x: sideOffset,
            y: bottomY,
            w: 40,
            h: 40,
            hp: 2500,
            maxHp: 2500,
            active: true,
            side: "player",
            type: "princess",
          },
          rightPrincess: {
            x: ARENA.width - sideOffset,
            y: bottomY,
            w: 40,
            h: 40,
            hp: 2500,
            maxHp: 2500,
            active: true,
            side: "player",
            type: "princess",
          },
        },
        bot: {
          king: {
            x: ARENA.width / 2,
            y: topY - kingOffsetY,
            w: 46,
            h: 46,
            hp: 4000,
            maxHp: 4000,
            active: false,
            side: "bot",
            type: "king",
          },
          leftPrincess: {
            x: sideOffset,
            y: topY,
            w: 40,
            h: 40,
            hp: 2500,
            maxHp: 2500,
            active: true,
            side: "bot",
            type: "princess",
          },
          rightPrincess: {
            x: ARENA.width - sideOffset,
            y: topY,
            w: 40,
            h: 40,
            hp: 2500,
            maxHp: 2500,
            active: true,
            side: "bot",
            type: "princess",
          },
        },
      };
    }

    let towers = createTowers();
    const units = [];
    const spells = [];

    // =========================
    // HELPERS
    // =========================
    function distance(a, b) {
      const dx = a.x - b.x;
      const dy = a.y - b.y;
      return Math.sqrt(dx * dx + dy * dy);
    }

    function getAllTowersArray() {
      return [
        towers.player.king,
        towers.player.leftPrincess,
        towers.player.rightPrincess,
        towers.bot.king,
        towers.bot.leftPrincess,
        towers.bot.rightPrincess,
      ];
    }

    function getEnemyTowers(side) {
      return side === "player"
        ? [towers.bot.leftPrincess, towers.bot.rightPrincess, towers.bot.king]
        : [towers.player.leftPrincess, towers.player.rightPrincess, towers.player.king];
    }

    // =========================
    // POCKETS ‚Äì BIGGER & FURTHER UP
    // =========================
    // Player pockets: on enemy side, near river, larger and higher (closer to river).
    function getPlayerPockets() {
      const pockets = [];
      const enemy = towers.bot;
      const king = enemy.king;

      const pocketTop = ARENA.riverY - 100;
      const pocketBottom = ARENA.riverY - 5;

      if (enemy.leftPrincess.hp <= 0) {
        const x1 = Math.min(enemy.leftPrincess.x, king.x) - 60;
        const x2 = Math.max(enemy.leftPrincess.x, king.x) + 60;
        pockets.push({ x1, x2, y1: pocketTop, y2: pocketBottom });
      }
      if (enemy.rightPrincess.hp <= 0) {
        const x1 = Math.min(enemy.rightPrincess.x, king.x) - 60;
        const x2 = Math.max(enemy.rightPrincess.x, king.x) + 60;
        pockets.push({ x1, x2, y1: pocketTop, y2: pocketBottom });
      }
      return pockets;
    }

    // Bot pockets: mirrored on player side.
    function getBotPockets() {
      const pockets = [];
      const enemy = towers.player;
      const king = enemy.king;

      const pocketTop = ARENA.riverY + 5;
      const pocketBottom = ARENA.riverY + 100;

      if (enemy.leftPrincess.hp <= 0) {
        const x1 = Math.min(enemy.leftPrincess.x, king.x) - 60;
        const x2 = Math.max(enemy.leftPrincess.x, king.x) + 60;
        pockets.push({ x1, x2, y1: pocketTop, y2: pocketBottom });
      }
      if (enemy.rightPrincess.hp <= 0) {
        const x1 = Math.min(enemy.rightPrincess.x, king.x) - 60;
        const x2 = Math.max(enemy.rightPrincess.x, king.x) + 60;
        pockets.push({ x1, x2, y1: pocketTop, y2: pocketBottom });
      }
      return pockets;
    }

    function pointInRect(x, y, r) {
      return x >= r.x1 && x <= r.x2 && y >= r.y1 && y <= r.y2;
    }

    function canPlaceCardAt(card, x, y, side) {
      if (card.spell) return true;

      if (side === "player") {
        if (y > ARENA.riverY + 10) return true;
        const pockets = getPlayerPockets();
        for (const p of pockets) {
          if (pointInRect(x, y, p)) return true;
        }
        return false;
      } else {
        if (y < ARENA.riverY - 10) return true;
        const pockets = getBotPockets();
        for (const p of pockets) {
          if (pointInRect(x, y, p)) return true;
        }
        return false;
      }
    }

    // =========================
    // SPAWNING
    // =========================
    function spawnUnit(card, x, y, side) {
      units.push({
        x,
        y,
        side,
        card,
        hp: card.hp,
        target: null,
        attackCooldown: 0,
        state: "move",
      });
    }

    function spawnSpell(card, x, y, side) {
      spells.push({
        x,
        y,
        side,
        card,
        time: 0.3,
      });

      const allTowers = getAllTowersArray();
      allTowers.forEach((t) => {
        if (t.hp > 0 && distance({ x, y }, t) <= card.radius) {
          t.hp -= card.dmg;
          if (t.hp < 0) t.hp = 0;

          if (t.type === "king") {
            t.active = true;
          }

          if (t.type === "princess" && t.hp <= 0) {
            const owner = t.side === "player" ? towers.player : towers.bot;
            owner.king.active = true;
          }
        }
      });

      units.forEach((u) => {
        if (u.hp > 0 && distance({ x, y }, u) <= card.radius) {
          u.hp -= card.dmg;
          if (u.hp < 0) u.hp = 0;
        }
      });
    }

    // =========================
    // INPUT ‚Äì DRAG & PREVIEW
    // =========================
    let draggingCard = null;   // { card, slotIndex }
    let previewX = 0;
    let previewY = 0;
    let isValidPlacement = false;

    function startDraggingCard(slotIndex) {
      const cardIndex = playerHandIndices[slotIndex];
      const card = getCardFromDeck(PLAYER_DECK, cardIndex);
      if (!card) return;
      if (elixir < card.cost) return;

      draggingCard = { card, slotIndex };
    }

    canvas.addEventListener("mousemove", (e) => {
      const rect = canvas.getBoundingClientRect();
      previewX = e.clientX - rect.left;
      previewY = e.clientY - rect.top;

      if (draggingCard) {
        isValidPlacement = canPlaceCardAt(draggingCard.card, previewX, previewY, "player");
      }
    });

    canvas.addEventListener("mouseup", (e) => {
      if (!draggingCard) return;
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      const card = draggingCard.card;
      const slotIndex = draggingCard.slotIndex;

      if (elixir >= card.cost && canPlaceCardAt(card, x, y, "player")) {
        elixir -= card.cost;
        updateElixirUI();

        if (card.spell) {
          spawnSpell(card, x, y, "player");
        } else {
          spawnUnit(card, x, y, "player");
        }

        cyclePlayerCard(slotIndex);
        renderHandUI();
      }

      draggingCard = null;
      isValidPlacement = false;
    });

    // =========================
    // BOT LOGIC
    // =========================
    let botDecisionTimer = 0;

    function botUpdate(dt) {
      botElixir = Math.min(ELIXIR_MAX, botElixir + botElixirRegen * dt);

      botDecisionTimer -= dt;
      if (botDecisionTimer > 0) return;

      botDecisionTimer = 1.0 + Math.random() * 1.2;

      const playableSlots = [];
      for (let i = 0; i < botHandIndices.length; i++) {
        const card = getCardFromDeck(BOT_DECK, botHandIndices[i]);
        if (card.cost <= botElixir) playableSlots.push(i);
      }
      if (playableSlots.length === 0) return;

      let defendTarget = null;
      let closestToBotKing = Infinity;
      const botKing = towers.bot.king;
      units.forEach((u) => {
        if (u.side === "player") {
          const d = distance(u, botKing);
          if (d < closestToBotKing) {
            closestToBotKing = d;
            defendTarget = u;
          }
        }
      });

      const slot = playableSlots[Math.floor(Math.random() * playableSlots.length)];
      const cardIndex = botHandIndices[slot];
      const card = getCardFromDeck(BOT_DECK, cardIndex);

      let x, y;

      if (defendTarget && Math.random() < 0.7) {
        x = defendTarget.x + (Math.random() * 40 - 20);
        y = defendTarget.y - 40 - Math.random() * 30;
      } else {
        x = 80 + Math.random() * (ARENA.width - 160);
        y = 40 + Math.random() * (ARENA.riverY - 80);
      }

      const pockets = getBotPockets();
      if (pockets.length > 0 && Math.random() < 0.4) {
        const p = pockets[Math.floor(Math.random() * pockets.length)];
        x = p.x1 + Math.random() * (p.x2 - p.x1);
        y = p.y1 + Math.random() * (p.y2 - p.y1);
      }

      if (!canPlaceCardAt(card, x, y, "bot")) return;

      botElixir -= card.cost;

      if (card.spell) {
        spawnSpell(card, x, y, "bot");
      } else {
        spawnUnit(card, x, y, "bot");
      }

      cycleBotCard(slot);
    }

    // =========================
    // PATHING & TARGETING
    // =========================
    function getGroundTargetPosition(unit, targetTower) {
      const goingUp = unit.side === "player";
      if ((goingUp && unit.y <= ARENA.riverY) || (!goingUp && unit.y >= ARENA.riverY)) {
        return { x: targetTower.x, y: targetTower.y };
      }

      const bridgeCenters = bridges.map((b) => ({ x: b.x + b.width / 2, y: ARENA.riverY }));
      let best = bridgeCenters[0];
      let bestDist = Math.abs(unit.x - best.x);
      for (let i = 1; i < bridgeCenters.length; i++) {
        const d = Math.abs(unit.x - bridgeCenters[i].x);
        if (d < bestDist) {
          bestDist = d;
          best = bridgeCenters[i];
        }
      }
      return best;
    }

    function canUnitTarget(unit, target) {
      if (!target) return false;
      if (target.hp !== undefined && target.hp <= 0) return false;

      const isTower = target.type === "king" || target.type === "princess";
      const isUnit = target.card !== undefined;

      if (unit.card.targetType === "building" && !isTower) return false;
      if (unit.card.targetType === "ground" && isUnit && target.card.type === "air") return false;

      return true;
    }

    function findUnitTarget(u) {
      let best = null;
      let bestDist = Infinity;

      units.forEach((other) => {
        if (other === u || other.hp <= 0) return;
        if (other.side === u.side) return;
        const d = distance(u, other);
        if (d <= u.card.aggroRange && d < bestDist && canUnitTarget(u, other)) {
          bestDist = d;
          best = other;
        }
      });

      if (best) return best;

      const enemyTowers = getEnemyTowers(u.side);
      enemyTowers.forEach((t) => {
        if (t.hp <= 0) return;
        const d = distance(u, t);
        if (d < bestDist && canUnitTarget(u, t)) {
          bestDist = d;
          best = t;
        }
      });

      return best;
    }

    function applySplashDamage(attacker, primaryTarget) {
      if (!attacker.card.splash) return;
      const radius = attacker.card.splashRadius || 40;
      units.forEach((u) => {
        if (u.side === primaryTarget.side && u !== primaryTarget && u.hp > 0) {
          if (distance(u, primaryTarget) <= radius) {
            u.hp -= attacker.card.dmg * 0.7;
            if (u.hp < 0) u.hp = 0;
          }
        }
      });
    }

    function updateUnits(dt) {
      units.forEach((u) => {
        if (u.hp <= 0) return;

        if (!u.target || (u.target.hp !== undefined && u.target.hp <= 0)) {
          u.target = findUnitTarget(u);
        } else {
          const d = distance(u, u.target);
          if (d > u.card.aggroRange * 1.4) {
            u.target = findUnitTarget(u);
          }
        }

        if (u.target) {
          const d = distance(u, u.target);
          const inRange = d <= u.card.range + 1;

          if (inRange) {
            u.state = "attack";
            u.attackCooldown -= dt;
            if (u.attackCooldown <= 0) {
              u.attackCooldown = u.card.attackSpeed;
              u.target.hp -= u.card.dmg;
              if (u.target.hp < 0) u.target.hp = 0;

              applySplashDamage(u, u.target);

              if (u.target.type === "princess" && u.target.hp <= 0) {
                const owner = u.target.side === "player" ? towers.player : towers.bot;
                owner.king.active = true;
              }
            }
          } else {
            u.state = "move";

            let targetPos;
            if (u.card.type === "ground" && (u.target.type === "king" || u.target.type === "princess")) {
              targetPos = getGroundTargetPosition(u, u.target);
            } else {
              targetPos = { x: u.target.x, y: u.target.y };
            }

            const dx = targetPos.x - u.x;
            const dy = targetPos.y - u.y;
            const len = Math.sqrt(dx * dx + dy * dy) || 1;
            const vx = (dx / len) * u.card.speed;
            const vy = (dy / len) * u.card.speed;

            u.x += vx * dt;
            u.y += vy * dt;
          }
        } else {
          const enemyTowers = getEnemyTowers(u.side).filter((t) => t.hp > 0);
          if (enemyTowers.length === 0) return;
          const primaryTarget = enemyTowers[0];

          let targetPos;
          if (u.card.type === "ground") {
            targetPos = getGroundTargetPosition(u, primaryTarget);
          } else {
            targetPos = { x: primaryTarget.x, y: primaryTarget.y };
          }

          const dx = targetPos.x - u.x;
          const dy = targetPos.y - u.y;
          const len = Math.sqrt(dx * dx + dy * dy) || 1;
          const vx = (dx / len) * u.card.speed;
          const vy = (dy / len) * u.card.speed;

          u.x += vx * dt;
          u.y += vy * dt;
        }
      });

      for (let i = units.length - 1; i >= 0; i--) {
        if (units[i].hp <= 0) units.splice(i, 1);
      }
    }

    // =========================
    // TOWERS ATTACK
    // =========================
    function updateTowers(dt) {
      const allTowers = getAllTowersArray();

      allTowers.forEach((t) => {
        if (t.hp <= 0) return;
        if (t.type === "king" && !t.active) return;

        if (!t.attackCooldown) t.attackCooldown = 0;
        t.attackCooldown -= dt;

        const baseRange = t.type === "king" ? 140 : 180;
        let nearest = null;
        let nearestDist = Infinity;

        units.forEach((u) => {
          if (u.side === t.side || u.hp <= 0) return;

          if (t.type === "princess") {
            if (t.side === "player" && u.y < ARENA.riverY - 5) return;
            if (t.side === "bot" && u.y > ARENA.riverY + 5) return;
          }

          const d = distance(u, t);
          if (d < nearestDist && d <= baseRange) {
            nearestDist = d;
            nearest = u;
          }
        });

        if (nearest && t.attackCooldown <= 0) {
          t.attackCooldown = 1;
          nearest.hp -= t.type === "king" ? 140 : 105;
          if (nearest.hp < 0) nearest.hp = 0;
        }
      });
    }

    // =========================
    // SPELLS
    // =========================
    function updateSpells(dt) {
      for (let i = spells.length - 1; i >= 0; i--) {
        spells[i].time -= dt;
        if (spells[i].time <= 0) spells.splice(i, 1);
      }
    }

    // =========================
    // GAME END
    // =========================
    function checkGameEnd() {
      if (towers.player.king.hp <= 0) return "bot";
      if (towers.bot.king.hp <= 0) return "player";
      return null;
    }

    // =========================
    // DRAWING
    // =========================
    function drawArena() {
      const topColor = "#3f7f4f";
      const bottomColor = "#2f5f3a";
      const gradient = ctx.createLinearGradient(0, 0, 0, ARENA.height);
      gradient.addColorStop(0, topColor);
      gradient.addColorStop(1, bottomColor);
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, ARENA.width, ARENA.height);

      ctx.fillStyle = "#3b7bbf";
      ctx.fillRect(0, ARENA.riverY - 20, ARENA.width, 40);

      ctx.fillStyle = "#b58b4a";
      bridges.forEach((b) => {
        ctx.fillRect(b.x, b.y, b.width, b.height);
      });

      ctx.strokeStyle = "rgba(0,255,0,0.25)";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(0, ARENA.riverY + 1);
      ctx.lineTo(ARENA.width, ARENA.riverY + 1);
      ctx.stroke();

      ctx.strokeStyle = "rgba(255,0,0,0.25)";
      ctx.beginPath();
      ctx.moveTo(0, ARENA.riverY - 1);
      ctx.lineTo(ARENA.width, ARENA.riverY - 1);
      ctx.stroke();
    }

    function drawTower(t) {
      if (t.hp <= 0) return;
      ctx.save();
      ctx.translate(t.x, t.y);

      if (t.type === "king") {
        ctx.fillStyle = t.side === "player" ? "#f4d35e" : "#5ea8f4";
        ctx.fillRect(-t.w / 2, -t.h / 2, t.w, t.h);

        ctx.fillStyle = t.side === "player" ? "#c98c3a" : "#2f6aa8";
        ctx.fillRect(-t.w / 2 + 4, -t.h / 2 + 4, t.w - 8, t.h - 16);

        ctx.fillStyle = t.active ? "#ff4444" : "#999";
        ctx.beginPath();
        ctx.arc(0, -t.h / 2 - 8, 9, 0, Math.PI * 2);
        ctx.fill();
      } else {
        ctx.fillStyle = t.side === "player" ? "#f4b35e" : "#5e9cf4";
        ctx.fillRect(-t.w / 2, -t.h / 2, t.w, t.h);

        ctx.fillStyle = t.side === "player" ? "#c97c3a" : "#2f5ea8";
        ctx.fillRect(-t.w / 2 + 4, -t.h / 2 + 4, t.w - 8, t.h - 12);

        ctx.fillStyle = "#ddd";
        ctx.beginPath();
        ctx.arc(0, -t.h / 2 - 5, 6, 0, Math.PI * 2);
        ctx.fill();
      }

      const hpPct = t.hp / t.maxHp;
      ctx.fillStyle = "#000";
      ctx.fillRect(-22, t.h / 2 + 5, 44, 5);
      ctx.fillStyle = hpPct > 0.4 ? "#0f0" : "#f00";
      ctx.fillRect(-22, t.h / 2 + 5, 44 * hpPct, 5);

      ctx.restore();
    }

    function drawUnit(u) {
      if (u.hp <= 0) return;
      ctx.save();
      ctx.translate(u.x, u.y);

      // more complex silhouettes per card
      if (u.card.id === "knight") {
        ctx.fillStyle = u.side === "player" ? "#c9a34f" : "#7fa0d9";
        ctx.beginPath();
        ctx.moveTo(-10, 18);
        ctx.lineTo(-14, -10);
        ctx.lineTo(0, -22);
        ctx.lineTo(14, -10);
        ctx.lineTo(10, 18);
        ctx.closePath();
        ctx.fill();
        ctx.fillStyle = "#444";
        ctx.fillRect(-8, -28, 16, 10);
        ctx.fillStyle = "#999";
        ctx.fillRect(-16, -6, 8, 4);
      } else if (u.card.id === "archers") {
        ctx.fillStyle = u.side === "player" ? "#7fd9ff" : "#ff9fd9";
        ctx.beginPath();
        ctx.ellipse(0, -4, 9, 12, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = "#fce";
        ctx.beginPath();
        ctx.arc(0, -16, 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = "#222";
        ctx.beginPath();
        ctx.moveTo(-10, 0);
        ctx.lineTo(10, 0);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(0, -4);
        ctx.lineTo(0, -18);
        ctx.stroke();
      } else if (u.card.id === "giant") {
        ctx.fillStyle = u.side === "player" ? "#d98b4f" : "#b5651d";
        ctx.beginPath();
        ctx.moveTo(-18, 20);
        ctx.lineTo(-20, -10);
        ctx.quadraticCurveTo(0, -30, 20, -10);
        ctx.lineTo(18, 20);
        ctx.closePath();
        ctx.fill();
        ctx.fillStyle = "#333";
        ctx.fillRect(-14, -32, 28, 10);
        ctx.fillStyle = "#f0c090";
        ctx.beginPath();
        ctx.arc(0, -40, 8, 0, Math.PI * 2);
        ctx.fill();
      } else if (u.card.id === "minions") {
        ctx.fillStyle = u.side === "player" ? "#6666ff" : "#4444aa";
        ctx.beginPath();
        ctx.arc(-8, 0, 7, 0, Math.PI * 2);
        ctx.arc(8, 0, 7, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = "#99f";
        ctx.beginPath();
        ctx.moveTo(-8, -7);
        ctx.lineTo(-16, -16);
        ctx.lineTo(-2, -10);
        ctx.closePath();
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(8, -7);
        ctx.lineTo(16, -16);
        ctx.lineTo(2, -10);
        ctx.closePath();
        ctx.fill();
        ctx.fillStyle = "#ccd";
        ctx.beginPath();
        ctx.arc(-8, 0, 3, 0, Math.PI * 2);
        ctx.arc(8, 0, 3, 0, Math.PI * 2);
        ctx.fill();
      } else if (u.card.id === "baby_dragon") {
        ctx.fillStyle = u.side === "player" ? "#4ff88a" : "#3bbf6a";
        ctx.beginPath();
        ctx.ellipse(0, 0, 16, 12, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = "#2a5";
        ctx.beginPath();
        ctx.moveTo(-16, 0);
        ctx.lineTo(-28, -10);
        ctx.lineTo(-24, 6);
        ctx.closePath();
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(16, 0);
        ctx.lineTo(28, -10);
        ctx.lineTo(24, 6);
        ctx.closePath();
        ctx.fill();
        ctx.fillStyle = "#fff";
        ctx.beginPath();
        ctx.arc(4, -4, 3, 0, Math.PI * 2);
        ctx.fill();
      } else if (u.card.id === "mini_pekka") {
        ctx.fillStyle = u.side === "player" ? "#88c" : "#446";
        ctx.beginPath();
        ctx.moveTo(-10, 18);
        ctx.lineTo(-12, -8);
        ctx.lineTo(0, -20);
        ctx.lineTo(12, -8);
        ctx.lineTo(10, 18);
        ctx.closePath();
        ctx.fill();
        ctx.fillStyle = "#222";
        ctx.fillRect(-8, -28, 16, 10);
        ctx.fillStyle = "#55f";
        ctx.fillRect(-4, -32, 8, 4);
      } else if (u.card.id === "musketeer") {
        ctx.fillStyle = u.side === "player" ? "#9cf" : "#6af";
        ctx.beginPath();
        ctx.ellipse(0, -4, 9, 12, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = "#fcd";
        ctx.beginPath();
        ctx.arc(0, -16, 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = "#333";
        ctx.fillRect(4, -10, 14, 4);
        ctx.fillRect(14, -12, 4, 8);
      } else if (u.card.id === "valkyrie") {
        ctx.fillStyle = u.side === "player" ? "#f96" : "#f75";
        ctx.beginPath();
        ctx.ellipse(0, 0, 16, 12, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = "#fcd";
        ctx.beginPath();
        ctx.arc(0, -14, 7, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = "#c33";
        ctx.beginPath();
        ctx.arc(0, 0, 20, 0, Math.PI * 2);
        ctx.stroke();
      } else if (u.card.id === "wizard") {
        ctx.fillStyle = u.side === "player" ? "#a6f" : "#84c";
        ctx.beginPath();
        ctx.moveTo(-10, 18);
        ctx.lineTo(-8, -8);
        ctx.lineTo(8, -8);
        ctx.lineTo(10, 18);
        ctx.closePath();
        ctx.fill();
        ctx.fillStyle = "#fcd";
        ctx.beginPath();
        ctx.arc(0, -16, 7, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = "#ffcc66";
        ctx.beginPath();
        ctx.arc(0, -4, 4, 0, Math.PI * 2);
        ctx.fill();
      } else {
        ctx.fillStyle = u.side === "player" ? "#ff66aa" : "#66ddff";
        ctx.beginPath();
        ctx.arc(0, 0, 10, 0, Math.PI * 2);
        ctx.fill();
      }

      const hpPct = u.hp / u.card.hp;
      ctx.fillStyle = "#000";
      ctx.fillRect(-12, 16, 24, 4);
      ctx.fillStyle = hpPct > 0.4 ? "#0f0" : "#f00";
      ctx.fillRect(-12, 16, 24 * hpPct, 4);

      ctx.font = "10px Arial";
      ctx.textAlign = "center";
      ctx.fillStyle = "#fff";
      ctx.fillText(u.card.name, 0, -26);

      ctx.restore();
    }

    function drawSpell(s) {
      ctx.save();
      ctx.globalAlpha = 0.5;
      ctx.fillStyle = s.card.id === "fireball" ? "#ff6600" : "#ffffff";
      ctx.beginPath();
      ctx.arc(s.x, s.y, s.card.radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    function drawPockets() {
      const pockets = getPlayerPockets();
      if (pockets.length === 0) return;

      ctx.save();
      ctx.lineWidth = 2;
      ctx.setLineDash([6, 4]);
      pockets.forEach((p) => {
        ctx.strokeStyle = "rgba(0,255,0,0.4)";
        ctx.strokeRect(p.x1, p.y1, p.x2 - p.x1, p.y2 - p.y1);
      });
      ctx.restore();
    }

    function drawPreview() {
      if (!draggingCard) return;
      const card = draggingCard.card;

      ctx.save();
      ctx.globalAlpha = 0.5;

      const colorTint = isValidPlacement ? "rgba(0,255,0,0.5)" : "rgba(255,0,0,0.5)";
      ctx.strokeStyle = colorTint;
      ctx.lineWidth = 2;

      const r = card.spell ? card.radius : (card.radius || 16);
      ctx.beginPath();
      ctx.arc(previewX, previewY, r, 0, Math.PI * 2);
      ctx.stroke();

      ctx.translate(previewX, previewY);
      ctx.globalAlpha = 0.6;

      if (!card.spell) {
        ctx.fillStyle = colorTint;
        if (card.id === "knight") {
          ctx.beginPath();
          ctx.moveTo(-10, 18);
          ctx.lineTo(-14, -10);
          ctx.lineTo(0, -22);
          ctx.lineTo(14, -10);
          ctx.lineTo(10, 18);
          ctx.closePath();
          ctx.fill();
        } else if (card.id === "archers") {
          ctx.beginPath();
          ctx.ellipse(0, -4, 9, 12, 0, 0, Math.PI * 2);
          ctx.fill();
        } else if (card.id === "giant") {
          ctx.beginPath();
          ctx.moveTo(-18, 20);
          ctx.lineTo(-20, -10);
          ctx.quadraticCurveTo(0, -30, 20, -10);
          ctx.lineTo(18, 20);
          ctx.closePath();
          ctx.fill();
        } else if (card.id === "minions") {
          ctx.beginPath();
          ctx.arc(-8, 0, 7, 0, Math.PI * 2);
          ctx.arc(8, 0, 7, 0, Math.PI * 2);
          ctx.fill();
        } else if (card.id === "baby_dragon") {
          ctx.beginPath();
          ctx.ellipse(0, 0, 16, 12, 0, 0, Math.PI * 2);
          ctx.fill();
        } else if (card.id === "mini_pekka") {
          ctx.beginPath();
          ctx.moveTo(-10, 18);
          ctx.lineTo(-12, -8);
          ctx.lineTo(0, -20);
          ctx.lineTo(12, -8);
          ctx.lineTo(10, 18);
          ctx.closePath();
          ctx.fill();
        } else if (card.id === "musketeer") {
          ctx.beginPath();
          ctx.ellipse(0, -4, 9, 12, 0, 0, Math.PI * 2);
          ctx.fill();
        } else if (card.id === "valkyrie") {
          ctx.beginPath();
          ctx.ellipse(0, 0, 16, 12, 0, 0, Math.PI * 2);
          ctx.fill();
        } else if (card.id === "wizard") {
          ctx.beginPath();
          ctx.moveTo(-10, 18);
          ctx.lineTo(-8, -8);
          ctx.lineTo(8, -8);
          ctx.lineTo(10, 18);
          ctx.closePath();
          ctx.fill();
        } else {
          ctx.beginPath();
          ctx.arc(0, 0, 10, 0, Math.PI * 2);
          ctx.fill();
        }
      } else {
        ctx.fillStyle = colorTint;
        ctx.beginPath();
        ctx.arc(0, 0, 10, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.restore();
    }

    function drawTowers() {
      const allTowers = getAllTowersArray();
      allTowers.forEach(drawTower);
    }

    function drawUnits() {
      units.forEach(drawUnit);
    }

    function drawSpells() {
      spells.forEach(drawSpell);
    }

    function drawGameOver(winner) {
      ctx.fillStyle = "rgba(0,0,0,0.7)";
      ctx.fillRect(0, 0, ARENA.width, ARENA.height);
      ctx.fillStyle = "#fff";
      ctx.font = "36px Arial";
      ctx.textAlign = "center";
      ctx.fillText(
        winner === "player" ? "You Win!" : "You Lose!",
        ARENA.width / 2,
        ARENA.height / 2
      );
      ctx.font = "20px Arial";
      ctx.fillText("Refresh the page to play again.", ARENA.width / 2, ARENA.height / 2 + 40);
    }

    // =========================
    // MAIN LOOP
    // =========================
    let lastTime = performance.now();
    let gameOver = false;
    let winner = null;

    function loop(now) {
      const dt = (now - lastTime) / 1000;
      lastTime = now;

      if (!gameOver) {
        gameTime += dt;

        if (!doubleElixir && gameTime >= 120) {
          doubleElixir = true;
          elixirRegen = elixirRegenBase * 2;
          botElixirRegen = elixirRegenBase * 2;
          doubleElixirBanner.style.display = "block";
        }

        elixir = Math.min(ELIXIR_MAX, elixir + elixirRegen * dt);
        updateElixirUI();

        botUpdate(dt);
        updateUnits(dt);
        updateTowers(dt);
        updateSpells(dt);

        winner = checkGameEnd();
        if (winner) {
          gameOver = true;
        }
      }

      drawArena();
      drawTowers();
      drawUnits();
      drawSpells();
      drawPockets();
      drawPreview();

      if (gameOver) {
        drawGameOver(winner);
      }

      requestAnimationFrame(loop);
    }

    requestAnimationFrame(loop);
  </script>
</body>
</html>
