<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Mini Clash Royale Prototype</title>
  <style>
    body {
      margin: 0;
      background: #222;
      color: #fff;
      font-family: Arial, sans-serif;
      text-align: center;
      user-select: none;
    }
    #gameContainer {
      margin: 10px auto;
      width: 900px;
    }
    #ui {
      margin-bottom: 8px;
    }
    #elixirBarOuter {
      width: 300px;
      height: 20px;
      border: 2px solid #fff;
      margin: 0 auto 4px;
      position: relative;
      background: #333;
    }
    #elixirBarInner {
      height: 100%;
      background: linear-gradient(90deg, #7b2cff, #ff4bff);
      width: 0%;
      transition: width 0.1s linear;
    }
    #elixirText {
      font-size: 14px;
      margin-bottom: 6px;
    }
    #cards {
      display: flex;
      justify-content: center;
      gap: 6px;
      flex-wrap: wrap;
    }
    .card {
      width: 80px;
      height: 100px;
      background: #444;
      border: 2px solid #888;
      border-radius: 6px;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-size: 12px;
    }
    .card.selected {
      border-color: #ffd700;
      box-shadow: 0 0 8px #ffd700;
    }
    .cardCost {
      font-weight: bold;
      margin-top: 4px;
      color: #ffd1ff;
    }
    canvas {
      background: #356c4a;
      border: 2px solid #fff;
      display: block;
      margin: 8px auto;
    }
    #info {
      margin-top: 6px;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <h1>Mini Clash Royale Prototype</h1>
    <div id="ui">
      <div id="elixirText">Elixir: 0 / 10</div>
      <div id="elixirBarOuter">
        <div id="elixirBarInner"></div>
      </div>
      <div id="cards"></div>
    </div>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div id="info">
      Click on the arena to place the selected card on your side.<br/>
      Ground troops must use bridges; air troops fly straight across.
    </div>
  </div>

  <script>
    // --- Basic setup ---
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    const ELIXIR_MAX = 10;
    const ELIXIR_REGEN_PER_SEC = 0.35; // tweak as desired
    let elixir = 5;
    let lastTime = performance.now();

    const elixirText = document.getElementById("elixirText");
    const elixirBarInner = document.getElementById("elixirBarInner");
    const cardsContainer = document.getElementById("cards");

    // --- Arena geometry ---
    const ARENA = {
      width: canvas.width,
      height: canvas.height,
      riverY: canvas.height / 2,
      bridgeWidth: 80,
      bridgeGap: 60,
    };

    // Bridges: two rectangles where ground units can cross the river
    const bridges = [
      {
        x: ARENA.width / 2 - ARENA.bridgeGap / 2 - ARENA.bridgeWidth,
        y: ARENA.riverY - 10,
        width: ARENA.bridgeWidth,
        height: 20,
      },
      {
        x: ARENA.width / 2 + ARENA.bridgeGap / 2,
        y: ARENA.riverY - 10,
        width: ARENA.bridgeWidth,
        height: 20,
      },
    ];

    // --- Towers ---
    function createTowers() {
      const bottomY = ARENA.height - 80;
      const topY = 40;
      const sideOffset = 120;
      const kingOffsetY = 40;

      return {
        player: {
          king: {
            x: ARENA.width / 2,
            y: bottomY + kingOffsetY,
            w: 40,
            h: 40,
            hp: 4000,
            maxHp: 4000,
            active: false,
            side: "player",
            type: "king",
          },
          leftPrincess: {
            x: sideOffset,
            y: bottomY,
            w: 40,
            h: 40,
            hp: 2500,
            maxHp: 2500,
            active: true,
            side: "player",
            type: "princess",
          },
          rightPrincess: {
            x: ARENA.width - sideOffset,
            y: bottomY,
            w: 40,
            h: 40,
            hp: 2500,
            maxHp: 2500,
            active: true,
            side: "player",
            type: "princess",
          },
        },
        bot: {
          king: {
            x: ARENA.width / 2,
            y: topY - kingOffsetY,
            w: 40,
            h: 40,
            hp: 4000,
            maxHp: 4000,
            active: false,
            side: "bot",
            type: "king",
          },
          leftPrincess: {
            x: sideOffset,
            y: topY,
            w: 40,
            h: 40,
            hp: 2500,
            maxHp: 2500,
            active: true,
            side: "bot",
            type: "princess",
          },
          rightPrincess: {
            x: ARENA.width - sideOffset,
            y: topY,
            w: 40,
            h: 40,
            hp: 2500,
            maxHp: 2500,
            active: true,
            side: "bot",
            type: "princess",
          },
        },
      };
    }

    let towers = createTowers();

    // --- Cards definition (sample set, easily extendable) ---
    // type: "ground" or "air"
    const CARDS = [
      { id: "knight", name: "Knight", cost: 3, speed: 40, hp: 800, dmg: 80, range: 20, type: "ground" },
      { id: "archers", name: "Archers", cost: 3, speed: 45, hp: 250, dmg: 60, range: 90, type: "air" },
      { id: "giant", name: "Giant", cost: 5, speed: 30, hp: 2000, dmg: 150, range: 20, type: "ground" },
      { id: "minions", name: "Minions", cost: 3, speed: 55, hp: 190, dmg: 70, range: 20, type: "air" },
      { id: "baby_dragon", name: "Baby Dragon", cost: 4, speed: 45, hp: 1200, dmg: 100, range: 80, type: "air" },
      { id: "mini_pekka", name: "Mini P.E.K.K.A", cost: 4, speed: 50, hp: 1100, dmg: 300, range: 20, type: "ground" },
      { id: "fireball", name: "Fireball", cost: 4, spell: true, radius: 60, dmg: 300 },
      { id: "arrows", name: "Arrows", cost: 3, spell: true, radius: 80, dmg: 150 },
    ];

    let selectedCardId = CARDS[0].id;

    // --- Units and spells in play ---
    const units = []; // {x,y,side,cardRef,hp,target,...}
    const spells = []; // simple timed effects

    // --- UI: render cards ---
    function renderCardUI() {
      cardsContainer.innerHTML = "";
      CARDS.forEach((card) => {
        const div = document.createElement("div");
        div.className = "card" + (card.id === selectedCardId ? " selected" : "");
        div.dataset.id = card.id;
        div.innerHTML = `
          <div>${card.name}</div>
          <div class="cardCost">${card.cost}</div>
        `;
        div.onclick = () => {
          selectedCardId = card.id;
          renderCardUI();
        };
        cardsContainer.appendChild(div);
      });
    }
    renderCardUI();

    // --- Elixir UI ---
    function updateElixirUI() {
      elixirText.textContent = `Elixir: ${elixir.toFixed(1)} / ${ELIXIR_MAX}`;
      const pct = (elixir / ELIXIR_MAX) * 100;
      elixirBarInner.style.width = `${Math.min(100, pct)}%`;
    }

    // --- Helpers ---
    function distance(a, b) {
      const dx = a.x - b.x;
      const dy = a.y - b.y;
      return Math.sqrt(dx * dx + dy * dy);
    }

    function getAllTowersArray() {
      return [
        towers.player.king,
        towers.player.leftPrincess,
        towers.player.rightPrincess,
        towers.bot.king,
        towers.bot.leftPrincess,
        towers.bot.rightPrincess,
      ];
    }

    function getEnemyTowers(side) {
      return side === "player"
        ? [towers.bot.leftPrincess, towers.bot.rightPrincess, towers.bot.king]
        : [towers.player.leftPrincess, towers.player.rightPrincess, towers.player.king];
    }

    function isOnPlayerSide(y) {
      return y > ARENA.riverY;
    }

    // --- Placement rules ---
    function canPlaceCardAt(card, x, y, side) {
      // Only allow placement on own side of arena
      if (side === "player" && y <= ARENA.riverY + 10) return false;
      if (side === "bot" && y >= ARENA.riverY - 10) return false;
      return true;
    }

    // --- Spawning units / spells ---
    function spawnUnit(card, x, y, side) {
      units.push({
        x,
        y,
        side,
        card,
        hp: card.hp,
        target: null,
        attackCooldown: 0,
      });
    }

    function spawnSpell(card, x, y, side) {
      spells.push({
        x,
        y,
        side,
        card,
        time: 0.3, // seconds visible
      });

      // Damage units and towers in radius
      const allTowers = getAllTowersArray();
      allTowers.forEach((t) => {
        if (t.hp > 0 && distance({ x, y }, t) <= card.radius) {
          t.hp -= card.dmg;
          if (t.hp < 0) t.hp = 0;

          // King activation rule: if king is hit by spell, activate
          if (t.type === "king") {
            t.active = true;
          }

          // If a princess tower dies, activate king on that side
          if (t.type === "princess" && t.hp <= 0) {
            const owner = t.side === "player" ? towers.player : towers.bot;
            owner.king.active = true;
          }
        }
      });

      units.forEach((u) => {
        if (u.hp > 0 && distance({ x, y }, u) <= card.radius) {
          u.hp -= card.dmg;
          if (u.hp < 0) u.hp = 0;
        }
      });
    }

    // --- Mouse input for player placement ---
    canvas.addEventListener("click", (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      const card = CARDS.find((c) => c.id === selectedCardId);
      if (!card) return;
      if (elixir < card.cost) return;
      if (!canPlaceCardAt(card, x, y, "player")) return;

      elixir -= card.cost;

      if (card.spell) {
        spawnSpell(card, x, y, "player");
      } else {
        spawnUnit(card, x, y, "player");
      }
    });

    // --- Bot logic: simple random placement ---
    let botElixir = 5;
    let botDecisionTimer = 0;

    function botUpdate(dt) {
      botElixir = Math.min(ELIXIR_MAX, botElixir + ELIXIR_REGEN_PER_SEC * dt);

      botDecisionTimer -= dt;
      if (botDecisionTimer <= 0) {
        botDecisionTimer = 1.5 + Math.random() * 1.5;

        // choose a random card it can afford
        const affordable = CARDS.filter((c) => c.cost <= botElixir);
        if (affordable.length === 0) return;
        const card = affordable[Math.floor(Math.random() * affordable.length)];

        // random position on bot side
        const x = 80 + Math.random() * (ARENA.width - 160);
        const y = 40 + Math.random() * (ARENA.riverY - 80);

        if (!canPlaceCardAt(card, x, y, "bot")) return;

        botElixir -= card.cost;
        if (card.spell) {
          spawnSpell(card, x, y, "bot");
        } else {
          spawnUnit(card, x, y, "bot");
        }
      }
    }

    // --- Pathing for ground units with bridges ---
    function getGroundTargetPosition(unit, targetTower) {
      // If already on enemy side, go straight to tower
      const goingUp = unit.side === "player";
      if ((goingUp && unit.y <= ARENA.riverY) || (!goingUp && unit.y >= ARENA.riverY)) {
        return { x: targetTower.x, y: targetTower.y };
      }

      // Need to cross river via nearest bridge
      const bridgeCenters = bridges.map((b) => ({ x: b.x + b.width / 2, y: ARENA.riverY }));
      let best = bridgeCenters[0];
      let bestDist = Math.abs(unit.x - best.x);
      for (let i = 1; i < bridgeCenters.length; i++) {
        const d = Math.abs(unit.x - bridgeCenters[i].x);
        if (d < bestDist) {
          bestDist = d;
          best = bridgeCenters[i];
        }
      }
      return best;
    }

    // --- Unit AI ---
    function updateUnits(dt) {
      const allTowers = getAllTowersArray();

      units.forEach((u) => {
        if (u.hp <= 0) return;

        // Find nearest enemy unit or tower in range
        let nearest = null;
        let nearestDist = Infinity;

        // enemy units
        units.forEach((other) => {
          if (other === u || other.hp <= 0) return;
          if (other.side === u.side) return;
          const d = distance(u, other);
          if (d < nearestDist) {
            nearestDist = d;
            nearest = other;
          }
        });

        // enemy towers
        allTowers.forEach((t) => {
          if (t.hp <= 0) return;
          if (t.side === u.side) return;
          const d = distance(u, t);
          if (d < nearestDist) {
            nearestDist = d;
            nearest = t;
          }
        });

        u.attackCooldown -= dt;

        if (nearest && nearestDist <= u.card.range) {
          // attack
          if (u.attackCooldown <= 0) {
            u.attackCooldown = 1; // 1 second per attack
            nearest.hp -= u.card.dmg;
            if (nearest.hp < 0) nearest.hp = 0;

            // King activation if princess dies
            if (nearest.type === "princess" && nearest.hp <= 0) {
              const owner = nearest.side === "player" ? towers.player : towers.bot;
              owner.king.active = true;
            }
          }
        } else {
          // move toward enemy king/princess towers
          const enemyTowers = getEnemyTowers(u.side).filter((t) => t.hp > 0);
          if (enemyTowers.length === 0) return;
          const primaryTarget = enemyTowers[0]; // simple: first alive

          let targetPos;
          if (u.card.type === "ground") {
            targetPos = getGroundTargetPosition(u, primaryTarget);
          } else {
            targetPos = { x: primaryTarget.x, y: primaryTarget.y };
          }

          const dx = targetPos.x - u.x;
          const dy = targetPos.y - u.y;
          const len = Math.sqrt(dx * dx + dy * dy) || 1;
          const vx = (dx / len) * u.card.speed;
          const vy = (dy / len) * u.card.speed;

          u.x += vx * dt;
          u.y += vy * dt;
        }
      });

      // Remove dead units
      for (let i = units.length - 1; i >= 0; i--) {
        if (units[i].hp <= 0) units.splice(i, 1);
      }
    }

    // --- Towers attacking ---
    function updateTowers(dt) {
      const allTowers = getAllTowersArray();

      allTowers.forEach((t) => {
        if (t.hp <= 0) return;
        if (t.type === "king" && !t.active) return;

        if (!t.attackCooldown) t.attackCooldown = 0;
        t.attackCooldown -= dt;

        // find nearest enemy unit in range
        const range = t.type === "king" ? 130 : 110;
        let nearest = null;
        let nearestDist = Infinity;

        units.forEach((u) => {
          if (u.side === t.side || u.hp <= 0) return;
          const d = distance(u, t);
          if (d < nearestDist && d <= range) {
            nearestDist = d;
            nearest = u;
          }
        });

        if (nearest && t.attackCooldown <= 0) {
          t.attackCooldown = 1;
          nearest.hp -= t.type === "king" ? 120 : 90;
          if (nearest.hp < 0) nearest.hp = 0;
        }
      });
    }

    // --- Spells update ---
    function updateSpells(dt) {
      for (let i = spells.length - 1; i >= 0; i--) {
        spells[i].time -= dt;
        if (spells[i].time <= 0) spells.splice(i, 1);
      }
    }

    // --- Win / lose check ---
    function checkGameEnd() {
      if (towers.player.king.hp <= 0) {
        return "bot";
      }
      if (towers.bot.king.hp <= 0) {
        return "player";
      }
      return null;
    }

    // --- Drawing ---
    function drawArena() {
      // background
      ctx.fillStyle = "#356c4a";
      ctx.fillRect(0, 0, ARENA.width, ARENA.height);

      // river
      ctx.fillStyle = "#3b7bbf";
      ctx.fillRect(0, ARENA.riverY - 20, ARENA.width, 40);

      // bridges
      ctx.fillStyle = "#b58b4a";
      bridges.forEach((b) => {
        ctx.fillRect(b.x, b.y, b.width, b.height);
      });

      // midline
      ctx.strokeStyle = "rgba(255,255,255,0.2)";
      ctx.beginPath();
      ctx.moveTo(0, ARENA.riverY);
      ctx.lineTo(ARENA.width, ARENA.riverY);
      ctx.stroke();
    }

    function drawTower(t) {
      if (t.hp <= 0) return;
      ctx.save();
      ctx.translate(t.x, t.y);
      ctx.fillStyle = t.side === "player" ? "#ffcc66" : "#66aaff";
      ctx.fillRect(-t.w / 2, -t.h / 2, t.w, t.h);

      // crown / king indicator
      if (t.type === "king") {
        ctx.fillStyle = t.active ? "#ff4444" : "#999";
        ctx.beginPath();
        ctx.arc(0, -t.h / 2 - 6, 8, 0, Math.PI * 2);
        ctx.fill();
      }

      // HP bar
      const hpPct = t.hp / t.maxHp;
      ctx.fillStyle = "#000";
      ctx.fillRect(-20, t.h / 2 + 4, 40, 5);
      ctx.fillStyle = "#0f0";
      ctx.fillRect(-20, t.h / 2 + 4, 40 * hpPct, 5);

      ctx.restore();
    }

    function drawUnit(u) {
      if (u.hp <= 0) return;
      ctx.save();
      ctx.translate(u.x, u.y);
      ctx.fillStyle = u.side === "player" ? "#ff66aa" : "#66ddff";
      ctx.beginPath();
      ctx.arc(0, 0, 10, 0, Math.PI * 2);
      ctx.fill();

      // air vs ground indicator
      ctx.fillStyle = u.card.type === "air" ? "#ffffff" : "#000000";
      ctx.fillRect(-6, -18, 12, 4);

      // HP bar
      const hpPct = u.hp / u.card.hp;
      ctx.fillStyle = "#000";
      ctx.fillRect(-12, 12, 24, 4);
      ctx.fillStyle = "#0f0";
      ctx.fillRect(-12, 12, 24 * hpPct, 4);

      ctx.restore();
    }

    function drawSpell(s) {
      ctx.save();
      ctx.globalAlpha = 0.5;
      ctx.fillStyle = s.card.id === "fireball" ? "#ff6600" : "#ffffff";
      ctx.beginPath();
      ctx.arc(s.x, s.y, s.card.radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    function drawTowers() {
      const allTowers = getAllTowersArray();
      allTowers.forEach(drawTower);
    }

    function drawUnits() {
      units.forEach(drawUnit);
    }

    function drawSpells() {
      spells.forEach(drawSpell);
    }

    function drawGameOver(winner) {
      ctx.fillStyle = "rgba(0,0,0,0.7)";
      ctx.fillRect(0, 0, ARENA.width, ARENA.height);
      ctx.fillStyle = "#fff";
      ctx.font = "36px Arial";
      ctx.textAlign = "center";
      ctx.fillText(
        winner === "player" ? "You Win!" : "You Lose!",
        ARENA.width / 2,
        ARENA.height / 2
      );
      ctx.font = "20px Arial";
      ctx.fillText("Refresh the page to play again.", ARENA.width / 2, ARENA.height / 2 + 40);
    }

    // --- Main loop ---
    let gameOver = false;
    let winner = null;

    function loop(now) {
      const dt = (now - lastTime) / 1000;
      lastTime = now;

      if (!gameOver) {
        // elixir regen
        elixir = Math.min(ELIXIR_MAX, elixir + ELIXIR_REGEN_PER_SEC * dt);
        updateElixirUI();

        // bot
        botUpdate(dt);

        // logic
        updateUnits(dt);
        updateTowers(dt);
        updateSpells(dt);

        winner = checkGameEnd();
        if (winner) {
          gameOver = true;
        }
      }

      // draw
      drawArena();
      drawTowers();
      drawUnits();
      drawSpells();

      if (gameOver) {
        drawGameOver(winner);
      }

      requestAnimationFrame(loop);
    }

    updateElixirUI();
    requestAnimationFrame(loop);
  </script>
</body>
</html>
